{
	// Configurations that control the TypeScript compiler
	"compilerOptions": {
		/*
    - target: JavaScript language version, 'eSNext' is the most modern version. So like 
      your react-code and typescript will be compiled into modern javascript.

    - target: TypeScript will emit class fields with 'define', which aligns with standards.
      
      So in JavaScript we have classes, and properties in those classes. There are two 
      ways for these properties to be emitted/generated by TypeScript when we convert TypeScript to JavaScript.
      If true, the class fields are created with 'Object.defineProperty' which are more 
      aligned with ECMASript standards. Else if false, class fields are assigned in the constructor function,
      which is older and not as consistent with how properties are defined in native JavaScript classes.

    - lib: Specifie library files to be included in compilation. So like 'DOM' is the 
      Document Object Model API, the 'DOM.Iterable' adds type definitions. It also allows us 
      to use 'for ... of', spread operators, and other things. ESNext includes type definitions
      for the latest ECMAScript features, allowing us project to have the latest JavaScript 
      capabilities. In essence, you don't really need to worry about any of this, and it's just here to give
      TypeScript the necessary type definitions for the web environment. 
    
    - allowJS: Whether or not to allow javascript files to be compiled. This could be useful
      to set to true when you're trying to work on a slow migration over to TypeScript.
    - skipLibCheck: Skips type checking of declaration files such as '.d.ts'. Essentially '.d.ts' files 
      are declaration files that provide type definitions for our code. They provide type information 
      for libraries, projects, etc. So there are a couple reasons we skip these:
      1. Compilation speed: Skipping improves compilation speeds 
      2. Third party libraries: Some third-party libraries may have incorrect or incomplete type definitions that 
         can block your compilation process, so skipping is alright.
      3. Legacy codebases: If you're in a legacy codebase, skipping these checks may help you migrate or  
         integrate TypeScript more smoothly.
      Of course the potential downsides are that we might miss out on errors in the type definitions 
      that we define or that third party libraries define.

    - esModuleInterop: If true, we enable emit interopability between CommonJS and ES module, else false.

      Emit interoperability refers to the TypeScript compiler's ability to generate 
      (or "emit") JavaScript code that is compatible with both CommonJS modules 
      (require/module.exports) and ES Modules (import/export).

      When this feature is enabled, it allows us to work seamlessly with both module systems, 
      ensuring that import/export and require/module.exports can coexist and function 
      correctly in the same codebase.

      This is crucial because many JavaScript projects, especially those incorporating
      third-party libraries, often have a mix of CommonJS and ES Module syntax. By 
      enabling emit interoperability, we ensure that despite having different syntax, these
      modules can work well together, avoiding compatibility issues and runtime errors.


    - allowSyntheticDefaultImports: Allows default imports from modules with no default export, useful when working with libraries that default to CommonJS

    - module: Defines the module system that your project will use to import and export code.

      NOTE: So esModuleInterop allows us project to work with other code regardless of module ystem.
      So this is other libraries which may a different module system, allowing them to work with our project, 
      but also dependencies if needed. But 'module' defines the module system this project will use.



    */
		"target": "ESNext",
		"useDefineForClassFields": true,
		"lib": ["DOM", "DOM.Iterable", "ESNext"],
		"allowJs": false,
		"skipLibCheck": true,
		"esModuleInterop": false,
		"allowSyntheticDefaultImports": true,
		"strict": true,
		"forceConsistentCasingInFileNames": true,
		"module": "ESNext",
		// Determines how modules are resolved, this uses Node.js-style module resolution
		"moduleResolution": "Node",
		// Allows importing json files directly
		"resolveJsonModule": true,

		/*
    - isolatedModules: Ensures each file can be transpiled separately without relying 
      on TypeScript's type information
    */
		"isolatedModules": true,
		// Prevents compiler from writing output files; useful for when you only want type-checking to your code.
		"noEmit": true,

		// Specifies how JSX should be transformed. So 'react-jsx' is the modern runtime
		"jsx": "react-jsx"
	},
	"include": ["src"],
	"references": [{ "path": "./tsconfig.node.json" }]
}
