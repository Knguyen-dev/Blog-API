
import Category from "../models/Category";
import Post from "../models/Post";
import { isValidObjectId } from "mongoose";
import { createError } from "../middleware/errorUtils";
import createSlug from "../middleware/createSlug";
import { Types } from "mongoose";

const findCategoryByID = async (id: string) => {
  // Ensure that the objectId is valid
  if (!isValidObjectId(id)) {
    throw createError(400, "Invalid category ID");
  }

  // Attempt to find category via ID, check if we actually found the category
  const category = await Category.findById(id);
  if (!category) {
    throw createError(404, "Category was not found!");
  }

  // Return the category
  return category;
}

/**
 * Create a category
 * 
 * @param title - Title of the category
 * @param description - Description of the category
 * @param userId - Person who is creating the category
 */
const createCategory = async (title: string, description: string, userId: string) => {

    // Create a slug from the title
    const slug = createSlug(title);
    const existingCategory = await Category.findOne({
      slug: slug
    })
    if (existingCategory) {
       throw createError(400, `The title entered creates a URL-friendly name that already exists for the category "${existingCategory.title}". Please use a different title to make it unique.`);
    }

    // Input is valid, so save the new category to the database
    const category = await Category.create({
      title: title,
      description: description,
      slug,
      lastUpdatedBy: userId
    });

    // Return the category
    return category;
}

/**
 * Deletes a category
 * 
 * @param id - Id of the category that we're deleting
 */
const deleteCategory = async(id: string) => {

  // Check that the iD of the category is valid
  if (!isValidObjectId(id)) {
    throw createError(400, "Invalid category ID");
  }

  // Attempt to delete the category via its ID
  const result = await Category.deleteOne({_id: id});

  // If result isn't defined, then that means the category being deleted wasn't found
  // So throw a 404 error.
  if (result.deletedCount === 0) {
    throw createError(404, "Category being deleted wasn't found!"); 
  }

  // Remove the category from all posts that have that category; using $unset to remove the field
  await Post.updateMany(
    { category: id },
    { $unset: { category: "" } }
  );

  // Return the deleted category
  return result;
}

/**
 * Update a category
 * @param id - Id of the category we are updating 
 * @param title - New title of the category 
 * @param description - New description of the category
 * @param userId - Id of the user that we are 
 */
const updateCategory = async(id: string, title: string, description: string, userId: string) => {

  // Attempt to find category via its ID
  const category = await findCategoryByID(id);

  // Compute the slug created by the new title
  const slug = createSlug(title);

  /*
  - If the slug has changed (due to the changing of the title), that means we need to do a database check to ensure that the
  new slug is unique.
  1. find a category, other than the current one being updated that has the same slug. Since
  2. If a category exists, the new slug generated by the new title is not unique so throw back an 
    error and indicate so.
  */
  if (category.slug !== slug) {
    const existingCategory = await Category.findOne({_id: {$ne: id}, slug});
    if (existingCategory) {
      throw createError(400, `The title entered creates a URL-friendly name that already exists for the category "${existingCategory.title}". Please use a different title to make it unique.`);
    }
  }

  // Data is good so update category, save changes, and return updated category
  category.title = title;
  category.description = description;
  category.slug = slug;
  category.lastUpdatedBy = new Types.ObjectId(userId);

  await category.save();

  return category;
}

// Database function for getting all categories available in the database
const getAllCategories = async () => {
  const categories = await Category.find();
  return categories;
}

/**
 * Database function for handling getting a category and posts that have that category.
 * 
 * @param id - Id of the category we want to fetch, and the posts related to it 
 * @param options - You can specify whether we want only published posts, and you can also specify an array 
 *                  of strings, which would make the title have to match at atleast one of those strings to 
 *                  get returned back
 */
const getCategoryAndPosts = async (id: string, options: { publishedOnly?: boolean, titles?: string[] } = {}) => {

  // Check if category id is valid before moving on
  if (!isValidObjectId(id)) {
    throw createError(400, "Invalid category ID");
  }

  // Create query for finding posts associated with category
  const basePostQuery: any = {
    category: id,
  };

  /*
  - If option.titles was defined:
  1. Create regex that will return posts that contain any of the strings 
    in the titles array. For if the title was 'title1,title2,scones' then our 
    regex would find any posts that contain the 'title1', 'title2',
    or scones in the title.

  - NOTE: Of course if there's only one title, then it's just 
    an array with a single thing. And option.titles kind of acts like a 
    list of keywords the user can define to look for posts with those 
    words in the title
  */
  if (options.titles) {
    const titleRegex = new RegExp(options.titles.join('|'), "i"); // Match any title in the list
    basePostQuery.title = titleRegex;
  }

  // If we only want published posts
  if (options.publishedOnly) {
    basePostQuery.isPublished = true;
  }

  // Fetch concurrently
  const [category, posts] = await Promise.all([
    Category.findById(id),
    Post.find(basePostQuery).populate("tags user category")
  ]);

  // If category wasn't found
  if (!category) {
    throw createError(404, "Category not found!"); 
  }

  // return the category and posts
  return {category, posts};
}

const categoryServices = {
  findCategoryByID,
  createCategory,
  deleteCategory,
  updateCategory,
  getAllCategories,
  getCategoryAndPosts,
}

export default categoryServices;